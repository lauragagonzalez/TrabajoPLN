---
title: "PRÁCTICA"
author: "Grupo 6"
date: "2025-11-30"
output: pdf_document
---
Participantes del grupo 6:

- Alba Santos Santiago: alba.santos@alumnos.upm.es

- Alfredo Antonio Aleix Ayuga: alfredo.aleix@alumnos.upm.es

- Mario de las Heras Calzada: mario.delasheras@alumnos.upm.es

- Miguel Galan Galaterra: mi.galan@alumnos.upm.es

- Laura García Gonzalez: laura.gagonzalez@alumnos.upm.es

- Adrian Gomez del Valle: adrian.gomezdelvalle@alumnos.upm.es

-  Rodrigo Nieto Rodriguez: rodrigo.nieto@alumnos.upm.es




Importamos las librerias que se utilizarán durante el trabajo. 
```{r}

```
AQUÍ EXPLICAR PARA QUE SE USA CADA LIBRERIA. 

Lo primero que tuvimos que hacer fue una función para clasificar las palabras según los afijos.
```{r}
afijos <- function(palabra) {
  palabra <- tolower(palabra)
  if(grepl("algia$", palabra)) return("dolor")
  if(grepl("^hipo|^hiper", palabra)) return("alteración")
  if(grepl("itis$", palabra)) return("infección")
  if(grepl("oma$", palabra)) return("cáncer")
  return(NA) # si la palabra no coincide con ningún afijo
}
```
Esta función covierte la palabra en minúsculas y comprueba si contiene alguno de los afijos médicos dados: las terminaciones en *-algia* se asocian con enfermedades relacionadas con el dolor, los prefijos *hipo-* o *hiper-* con alteraciones funcionales, las terminaciones en *-itis* con procesos infecciosos y las terminaciones en *-oma* con patologías de tipo canceroso.

La función devuelve la categoría correspondiente de cada palabra o un valor nulo si no encuentra ninguna coincidencia.


Luego, continuamos con una función que nos construyera los sintagmas nominales.
```{r}
sintagmas_nominales <- function(anotacion) {
  n <- nrow(anotacion)
  results <- data.frame()
  for(i in 1:n) {
    upos_i <- anotacion$upos[i]
    # Solo procesamos si es NOUN o PROPN
    if(!is.na(upos_i) && (upos_i == "NOUN" || upos_i == "PROPN")) {
      izquierda <- i
      while(izquierda > 1 &&
            !is.na(anotacion$upos[izquierda-1]) &&
            (anotacion$upos[izquierda-1] == "ADJ" ||
             anotacion$upos[izquierda-1] == "NOUN" ||
             anotacion$upos[izquierda-1] == "PROPN")) {
        izquierda <- izquierda - 1
      }
      derecha <- i
      while(derecha < n &&
            !is.na(anotacion$upos[derecha+1]) &&
            (anotacion$upos[derecha+1] == "ADJ" ||
             anotacion$upos[derecha+1] == "NOUN" ||
             anotacion$upos[derecha+1] == "PROPN")) {
        derecha <- derecha + 1
      }
      
      phrase_tokens <- anotacion$token[izquierda:derecha]
      phrase_text <- paste(phrase_tokens, collapse = " ")
      
      results <- rbind(
        results,
        data.frame(
          text = phrase_text,
          head_id = i,
          start = izquierda,
          end = derecha,
          stringsAsFactors = FALSE
        )
      )
    }
  }
  rownames(results) <- NULL
  return(results)
}
```
Esta función construye frases nominales completas a partir de las antoaciónes lingüisticas generadas por el modelo de análisis **udpipe**. Recorre cada token del texto y, cuando identifica un sustantivo o nombre propio, se expande hacia la izquierda y hacia la derecha para incluir adjetivos u otros sustantivos o nombres propios que lo acompaña, formando así el sintagma completo. El objetivo de esta función es que, en vez de que se analizen solo palabras aisladas (que pierden significado), se analize frases nominales que capturan mejor los nombres de enfermedades en el contexto del artículo. 

Un ejemplo de como funciona es el siguiente: si encuentra la palabra "enterocolitis" junto al adjetivo "neutropénica", la función devolverá el sintagma "enerocolitis neutropénica".


Funcion que busca enfermedades: 
```{r}
buscar_enfermedades <- function(anotacion) {
  sintagmas <- sintagmas_nominales(anotacion)
  
  clasificar_sintagma <- function(frase) {
    palabras <- strsplit(frase, "\\s+")[[1]]
    clases <- sapply(palabras, afijos)
    clases_validas <- clases[!is.na(clases)]
    
    if (length(clases_validas) == 0) {
      return(NA)
    }
    clases_validas[1]
  }
  
  sintagmas$categoria <- sapply(sintagmas$text, clasificar_sintagma)
  
  sintagmas[!is.na(sintagmas$categoria),
            c("text", "categoria", "head_id", "start", "end")]
}
```
Esta función recibe como entrada la anotación lingüística generada por **udpipe**, construye los sintagmas nominales llamando a la función sintagmas_nominales. A continuación, para cada sintagma, separa sus palabras y aplica la función afijos a cada una de ellas.
Si alguna palabra contiene un afijo médico de los definidos (-algia, hipo-, hiper-, -itis, -oma), el sintagma se clasifica según la primera categoría encontrada (dolor, alteración, infección o cáncer).
Finalmente, la función devuelve únicamente los sintagmas que han podido ser clasificados como posibles enfermedades, junto con su categoría y la información de posición en el texto.


Lo opcional:
```{r}
buscar_enfermedad <- function(palabra) {
  url <- paste0("https://www.cun.es/diccionario-medico/terminos/", palabra)
  lines <- readLines(url)
  
  # Obtiene la definición
  comienzo_inf <- grep("<section class=\"textImageComponent textImageComponent\">", lines)[1]+1
  length_inf <- grep("^<h2>", lines[comienzo_inf+1:length(lines)])[1]-1
  text <- lines[comienzo_inf:(comienzo_inf+length_inf)]
  
  # Elimina las líneas con cabeceras si tiene
  cabeceras <- grep("<h2>", text)
  if (length(cabeceras) != 0){
    text <- text[-cabeceras]
  }
  
  info <- paste(unlist(lapply(text, limpiarTexto)), collapse="\n")
  traducirTexto(info)
}

# Función auxiliar que elimina las etiquetas de HTML
limpiarTexto<-function(cadena){
  res<-gsub("<[^<>]*>", "", cadena)
  trimws(res)
}

# Función auxiliar que traduce las letras con tilde y la eñe
traducirTexto <- function(cadena){
  trad <- list(c("&aacute;", "á"),
               c("&Aacute;", "Á"),
               c("&eacute;", "e"),
               c("&Eacute;", "É"),
               c("&iacute;", "í"),
               c("&Iacute;", "Í"),
               c("&oacute;", "ó"),
               c("&Oacute;", "Ó"),
               c("&uacute;", "ú"),
               c("&Uacute;", "Ú"),
               c("&ntilde;", "ñ"),
               c("&Ntilde;", "Ñ"),
               c("&iquest;", "¿"),
               c("&iexcl;", "¡"),
               c("&laquo;", "«"),
               c("&raquo;", "»"),
               c("&ndash;", "-")
  )
  stri_replace_all_regex(cadena,
                         pattern=unlist(lapply(trad, function(x){x[1]})),
                         replacement=unlist(lapply(trad, function(x){x[2]})),
                         vectorize=FALSE)
}
```
Dada una enfermedad, esta función obtiene su definición de del diccionario médico de la Clínica Universidad de Navarra. Para ello, obtiene toda la información de la web de la CUN de la enfermedad buscada y filtra la información para quedarse solo con la definición que se devuelve en una cadena de texto. En caso de contener varios párrafos la definición, estos se separan mediante los carácteres "\\n". 

Además, se han creado dos funciones auxiliares que limpian el texto y traducen algunos símbolos para que se pueda leer de manera correcta.   



La funcion que analiza loa articulos del json:
```{r}
analizar_articulos <- function(json_file, modelo_udpipe, n = 100) {
  lines <- readLines(json_file)
  data_list <- lapply(lines, jsonlite::fromJSON)
  data_df <- do.call(rbind, lapply(data_list, as.data.frame))
  set.seed(123)
  idx <- sample(nrow(data_df), min(n, nrow(data_df)))
  seleccionados <- data_df[idx, ]
  resultados <- vector("list", length = nrow(seleccionados))
  for (i in seq_len(nrow(seleccionados))) {
    texto <- seleccionados$abstractText[i]
    anotacion <- udpipe_annotate(modelo_udpipe, x = texto)
    anotacion <- as.data.frame(anotacion)
    enfermedades <- buscar_enfermedades(anotacion)
    if (!is.null(enfermedades) && nrow(enfermedades) > 0) {
      enfermedades$id_articulo <- seleccionados$id[i]
    }
    resultados[[i]] <- enfermedades
  }
  resultados_df <- do.call(rbind, resultados)
  return(resultados_df)
}
```

La sentencia de prueba (usar solo 100 articulos aleatorios porque el archivo .json es muy largo):
```{r}
resultados <- analizar_articulos("MESINESP_ORIGINAL_TRAINING.json", udmodel_es, n = 100)
```

Tareas realizadas por cada uno: YO AQUÍ DIVIDIRÍA A PARTES IGUALES EL GRUPO PARA QUE NO HAYA LIOS Y LISTO.
